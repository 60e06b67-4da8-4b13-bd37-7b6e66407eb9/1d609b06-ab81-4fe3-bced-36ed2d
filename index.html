<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="noindex, nofollow" />
    <title>valentinka</title>
    <style>
        body {
            background-color: pink;
            font-family: Arial, sans-serif;
        }

        h1 {
            text-align: center;
            margin-top: 20%;
        }

        /* Dimmed background overlay */
        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
        }

        /* Popup box */
        #popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #e09f9f;
            padding: 20px;
            border-radius: 8px;
            min-width: 200px;
            display: none;
            text-align: center;
            z-index: 999999999999999;
        }
    </style>
</head>

<body style="
  margin:0;
  min-height:100vh;
  display:flex;
  flex-direction:column;
  padding:16px;
  box-sizing:border-box;
  overflow:hidden;
">

    <!-- <h1 style="color:#6a395f; margin:0 0 12px 0; font-family: 'Brush Script MT'; font-size:50px;">
        –ë—É–¥–µ—à—å –ª–∏ —Ç—ã –º–æ–µ–π –≤–∞–ª–µ–Ω—Ç–∏–Ω–∫–æ–π
    </h1> -->

    <img src="resources/title.png" alt="ja">

    <div id="overlay"></div>

    <div id="popup">
        <p>–ë—É–¥—å –≥–æ—Ç–æ–≤–∞ –≤ 13:00;&rpar;</p>
    </div>

    <!-- Question mark -->
    <div class="wrapper">
        <!-- BEFORE (two images + ?) -->
        <div id="stage" class="merge-stage">
            <img class="piece left" src="resources/sleva.png" alt="ja">
            <span class="qm">?</span>
            <img class="piece right" src="resources/sprava.png" alt="ty">
        </div>

        <!-- AFTER (the merged result) -->
        <div id="result" class="merge-result" aria-hidden="true">
            <img src="resources/merged.png" alt="merged" />
        </div>
    </div>
    <style>
        .wrapper {
            width: 100%;
        }

        /* Keep both layers in the same spot */
        .merge-stage,
        .merge-result {
            width: 100%;
            height: 160px;
            /* adjust for your images */

            display: flex;
            align-items: center;
            justify-content: space-between;
            overflow: hidden;
        }

        .piece {
            width: 90px;
            height: 120px;
            object-fit: cover;
            will-change: transform, opacity;
            transition:
                transform 1400ms cubic-bezier(.2, .9, .2, 1),
                opacity 250ms ease;
        }

        .qm {
            flex: 1;
            text-align: center;
            font-size: 120px;
            color: #6a395f;
            line-height: 1;
            font-family: "Brush Script MT", cursive;
            transition: opacity 250ms ease;
            user-select: none;
        }

        /* Result hidden initially */
        .merge-result {
            display: none;
            justify-content: center;
        }

        .merge-result img {
            width: 180px;
            /* whatever fits your new image */
            height: 120px;
            object-fit: cover;
        }

        /* --- MERGE ANIMATION STATE --- */
        .merge-stage.is-merging .qm {
            opacity: 0;
        }

        /* We set the translateX values via JS so it always moves exactly to center */
        .merge-stage.is-merging .piece.left {
            transform: translateX(var(--move-left, 0px));
        }

        .merge-stage.is-merging .piece.right {
            transform: translateX(var(--move-right, 0px));
        }

        /* Optional: little ‚Äúflash‚Äù at the moment of merge */
        .merge-stage.is-merging::after {
            content: "";
            position: absolute;
            left: 50%;
            top: 50%;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
            opacity: 0;
            background: #fff;
            transition: transform 250ms ease, opacity 250ms ease;
            pointer-events: none;
        }

        .merge-stage.is-merging.flash::after {
            transform: translate(-50%, -50%) scale(18);
            opacity: 0.9;
        }

        /* After stage becomes invisible */
        .merge-stage.is-hidden {
            opacity: 0;
            transition: opacity 250ms ease;
            pointer-events: none;
        }
    </style>

    <!-- Button -->
    <button id="myBtn" style="
  width:100%;
  padding:16px 0;
  font-size:18px;
  border-radius:10px;
  background:#9b83cd;
  color:#000;
  border:2px solid #000;
  -webkit-appearance:none;
  appearance:none;
  transition:background 0.25s ease, transform 0.1s ease;
  cursor:pointer;
  touch-action:manipulation;
  margin-top:20px;
  flex:0 0 auto;
    ">
        ‚ú®‚ú®‚ú® <b>–¥–∞</b> ‚ú®‚ú®‚ú®
    </button>

    <!-- Gallery -->
    <div style="
  display:flex;
  gap:24px;
  width:100%;
  flex:1 1 auto;
  min-height:0;
  align-items:stretch;
  overflow:hidden;
">

        <!-- Left column -->
        <div style="
    flex:1;
    display:flex;
    flex-direction:column;
    justify-content:center;
    align-items:center;
    min-height:0;
  ">
            <img src="resources/sea_lion.gif" style="max-width:50%; height:auto; margin-bottom:8px;">
            <img src="resources/snowmans.png" style="max-width:60%; height:auto; margin-bottom:22px;">
            <img src="resources/cat-and-bear.gif" style="max-width:80%; height:auto; margin-bottom:20px;">
        </div>

        <!-- Right column -->
        <div style="
    flex:1;
    display:flex;
    flex-direction:column;
    justify-content:center;
    align-items:center;
    min-height:0;
  ">
            <img src="resources/kitties.gif" style="max-width:55%; height:auto; margin-bottom:30px;">
            <img src="resources/flower_emoji.png" style="max-width:80%; height:auto; margin-bottom:9px;">
        </div>

    </div>

</body>


<script>
    function openPopupDelayed() {
        setTimeout(() => {
            document.getElementById("overlay").style.display = "block";
            document.getElementById("popup").style.display = "block";
        }, 1500);
    }
    const stage = document.getElementById("stage");
    const result = document.getElementById("result");

    function computeMovesToCenter() {
        const leftImg = stage.querySelector(".piece.left");
        const rightImg = stage.querySelector(".piece.right");

        const stageRect = stage.getBoundingClientRect();
        const leftRect = leftImg.getBoundingClientRect();
        const rightRect = rightImg.getBoundingClientRect();

        const stageCenterX = stageRect.left + stageRect.width / 2;
        const leftCenterX = leftRect.left + leftRect.width / 2;
        const rightCenterX = rightRect.left + rightRect.width / 2;

        const moveLeft = stageCenterX - leftCenterX;
        const moveRight = stageCenterX - rightCenterX;

        stage.style.setProperty("--move-left", `${moveLeft}px`);
        stage.style.setProperty("--move-right", `${moveRight}px`);
    }

    // If layout changes (responsive), re-compute
    window.addEventListener("resize", () => {
        if (!stage.classList.contains("is-merging")) return;
        computeMovesToCenter();
    });

    const btn = document.getElementById("myBtn");

    btn.addEventListener("click", () => {
        emojiRain.start({
            emojis: ['ü§ç', 'üíù', '‚ú®', 'üíñ'],
            spawnRate: 40,     // more = denser
            maxOnScreen: 300,  // cap
            sizeMin: 12,
            sizeMax: 20
        })

        // prevent re-click while animating
        if (stage.classList.contains("is-merging")) return;

        // calculate exact translation to center (responsive-safe)
        computeMovesToCenter();

        // start animation
        stage.classList.add("is-merging");

        // optional flash near the end
        setTimeout(() => stage.classList.add("flash"), 600);

        // when motion finishes: hide stage, show result
        // (matches 700ms transition above)
        setTimeout(() => {
            stage.classList.add("is-hidden");
            stage.style.display = "none";

            result.style.display = "flex";
            result.setAttribute("aria-hidden", "false");
        }, 750);

        openPopupDelayed();
    });
</script>

<!-- Put this near the end of <body> -->
<script>
    (() => {
        // ======= CONFIG YOU CAN TWEAK =======
        const DEFAULTS = {
            emojis: ["‚ú®", "üíñ", "üî•", "üçÄ", "üåà", "‚≠ê", "üéâ", "üí´", "ü´ß"],
            // Overall intensity:
            spawnRate: 25,        // emojis per second
            maxOnScreen: 220,     // cap to prevent lag
            // Visuals / motion:
            sizeMin: 10,          // px
            sizeMax: 22,          // px
            speedMin: 90,         // px/sec
            speedMax: 280,        // px/sec
            swayMax: 40,          // px sideways amplitude
            rotateMax: 25,        // deg/sec
            // Lifetime:
            startY: -30,          // spawn above viewport
            endPadding: 40        // extra below viewport before recycling
        };

        // Respect users who prefer reduced motion.
        const prefersReducedMotion = window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches;

        // ======= INTERNALS =======
        let running = false;
        let container = null;
        let rafId = null;
        let lastT = 0;
        let spawnAcc = 0;

        const pool = [];        // recycled <span>
        const active = [];      // active particle objects

        function rand(min, max) { return min + Math.random() * (max - min); }
        function pick(arr) { return arr[(Math.random() * arr.length) | 0]; }

        function ensureContainer() {
            if (container) return;

            container = document.createElement("div");
            container.id = "emoji-rain";
            container.setAttribute("aria-hidden", "true");
            document.body.appendChild(container);

            // Minimal CSS injected once (avoids needing a separate stylesheet)
            const style = document.createElement("style");
            style.textContent = `
      #emoji-rain {
        position: fixed;
        inset: 0;
        pointer-events: none;
        overflow: hidden;
        z-index: 999999;
        contain: layout paint style;
      }
      #emoji-rain .e {
        position: absolute;
        left: 0;
        top: 0;
        will-change: transform;
        transform: translate3d(0,0,0);
        user-select: none;
        line-height: 1;
        filter: drop-shadow(0 1px 0 rgba(0,0,0,0.15));
      }
    `;
            document.head.appendChild(style);
        }

        function makeSpan() {
            const el = document.createElement("span");
            el.className = "e";
            container.appendChild(el);
            return el;
        }

        function spawn(cfg, viewportW) {
            if (active.length >= cfg.maxOnScreen) return;

            const el = pool.pop() || makeSpan();

            const size = rand(cfg.sizeMin, cfg.sizeMax);
            const x = rand(0, Math.max(0, viewportW - size));
            const y = cfg.startY;

            const speed = rand(cfg.speedMin, cfg.speedMax);
            const sway = rand(-cfg.swayMax, cfg.swayMax);
            const swaySpeed = rand(0.8, 1.8); // Hz-ish
            const rotSpeed = rand(-cfg.rotateMax, cfg.rotateMax);

            el.textContent = pick(cfg.emojis);
            el.style.fontSize = size + "px";

            active.push({
                el,
                x,
                y,
                baseX: x,
                speed,
                sway,
                swaySpeed,
                rot: rand(0, 360),
                rotSpeed
            });
        }

        function recycle(i) {
            const p = active[i];
            p.el.remove(); // detach from DOM (reduces layout cost when many)
            // Keep element for reuse, but re-append on spawn.
            pool.push(p.el);
            active.splice(i, 1);
        }

        function tick(t, cfg) {
            if (!running) return;

            const now = t || performance.now();
            const dt = Math.min(0.033, (now - lastT) / 1000 || 0); // clamp to ~33ms
            lastT = now;

            const vw = window.innerWidth;
            const vh = window.innerHeight;

            // Spawn based on rate (emojis/sec)
            spawnAcc += cfg.spawnRate * dt;
            while (spawnAcc >= 1) {
                spawnAcc -= 1;
                // If element was recycled via remove(), we must re-append on reuse:
                const needAppend = pool.length > 0;
                spawn(cfg, vw);
                if (needAppend && active.length) {
                    const last = active[active.length - 1];
                    // If it came from pool, it was removed; append again:
                    if (!last.el.isConnected) container.appendChild(last.el);
                }
            }

            // Update positions
            for (let i = active.length - 1; i >= 0; i--) {
                const p = active[i];

                p.y += p.speed * dt;
                p.rot += p.rotSpeed * dt;

                // Sway: baseX + sin(time * speed) * amplitude
                const swayX = Math.sin((now / 1000) * p.swaySpeed * Math.PI * 2) * p.sway;
                const x = p.baseX + swayX;

                // Only transform: fast, no layout
                p.el.style.transform = `translate3d(${x}px, ${p.y}px, 0) rotate(${p.rot}deg)`;

                if (p.y > vh + cfg.endPadding) {
                    recycle(i);
                }
            }

            rafId = requestAnimationFrame((nt) => tick(nt, cfg));
        }

        // ======= PUBLIC API =======
        window.emojiRain = {
            start(options = {}) {
                if (prefersReducedMotion) return; // silently do nothing
                ensureContainer();
                if (running) return;

                // Merge config
                const cfg = { ...DEFAULTS, ...options };
                if (!Array.isArray(cfg.emojis) || cfg.emojis.length === 0) cfg.emojis = DEFAULTS.emojis;

                running = true;
                lastT = performance.now();
                spawnAcc = 0;

                rafId = requestAnimationFrame((t) => tick(t, cfg));
            },

            stop({ clear = true } = {}) {
                running = false;
                if (rafId) cancelAnimationFrame(rafId);
                rafId = null;

                if (clear) {
                    // Remove active elements
                    for (let i = active.length - 1; i >= 0; i--) {
                        active[i].el.remove();
                        pool.push(active[i].el);
                        active.pop();
                    }
                }
            }
        };
    })();
</script>


</html>